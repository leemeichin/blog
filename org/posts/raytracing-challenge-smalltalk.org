#+TITLE: Ray Tracer Challenge: Smalltalk
#+DATE: <2021-12-12 Sun>
#+CATEGORY: programming

Dear diary,

It looks like I have some time off coming up, and it feels like a good chance to try something different. I've had The Ray Tracer Challenge[fn:1] for almost a year now and haven't even touched it yet! And it would be really cool to make use of that copy of the Smalltalk-80 Purple Book I've had lying around for almost as long.

I wonder how far we can get in the space of a week. Don't worry, diary, I'll let you know how it goes.

Just so I don't forget, here's a picture of what I would like to achieve.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/thegoal.jpg
[[../../assets/img/raytracing-challenge-smalltalk/thegoal.jpg]]

#+TOC: headlines 3

** Day 1

*** Setting up my environment

So it looks like I can choose Pharo, Squeak, or GNU Smalltalk[fn:3]. The introduction to the GNU version says it closely follows Smalltalk-80, so that should be useful I think! It also says it's headless, so it can be used with files, and has some bindings to graphics libraries like SDL[fn:4], but doesn't have a graphical environment like the other two.

Documentation seems fairly minimal but apparently Smalltalk is self-descriptive, so many I'm not supposed to be searching the web for these things.

Perhaps I'll get Squeak ready instead.

*** This Smalltalk book is quite weird

Hm, a lot of the examples in the Purple Book don't seem to directly correspond to the syntax I would type into the environment. The implementation description reads like a spec, in layout and formatting, so I'm not sure if that's something I actually write in code somewhere.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/book-syntax.jpg
[[../../assets/img/raytracing-challenge-smalltalk/book-syntax.jpg]]

I can only assume this is all in reference to the original Smalltalk environment. The thing is I can make sense of what it's describing, I'm just not sure how to /write/ it or where I would actually put this code.

That said, I really do like this way of documenting code and it's clear some thought has been put into how to organise it too. It reminds me a bit of regions in C# or pragmas in Objective-C, except that those use special comments to group things in large objects.

*** How the fuck do you actually do something?

Alright, people say that switching from object-oriented code like Ruby or Java to something pure functional like Haskell is difficult, because it requires a different way of thinking.

I challenge that assertion!

It would still take me only a few minutes to do a trivial hello world in Haskell, C, Ruby, Java, C++, Javascript, or any other similar language. I put *code* into a *file* and then I point the interpreter or compiler to that file and then I either get ~"Hello, World!"~ straight away or a nice executable that will then print it out.

The example in Smalltalk is to open a workspace and use an object called ~Transcript~, but it doesn't seem much different to doing ~console.log~ inside my browser's console.

#+begin_src smalltalk
  "Semicolon is called cascading, which is like method chaining"
  Transcript open; show: 'Hello world!'.
#+end_src

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/helloworld.png
[[../../assets/img/raytracing-challenge-smalltalk/helloworld.png]]

I guess that's enough to play around with things, but I want to do this ray tracer challenge and for that I need to learn how to make classes. Then I can use the workspace or a special renderer class to make it appear on the screen.

So, it looks like I probably have to do something with the browser, to set up a little hierarchy for my project. Looking through the stuff that's there, there's all sorts of stuff I can look at. And the code that appears when I click on a selector looks super similar to how things are printed in the Purple Book.

*** Thinking in images

I ordered a copy of Squeak By Example[fn:5] to help out, since I feel like I have to unlearn how I normally do programming. I'm so used to building everything as a hierarchy of files and directories, or placing everything into just a handful of files to begin with.

Turns out you have an /image/ and everything you do is saved inside it, and you basically live inside that image. Those workspaces are essentially REPLs, then, but you can also open as many of those as you want and when you save and reload the image, they will all be there still. Pretty cool!

Actually, it makes me wonder how you deploy stuff for other people to use, but that's a question for another time.

Anyway, I think I've done enough today. I'm sure that once I understand the fundamentals I can start thinking about the challenge I want to complete.

** Day 2

Squeak by Example arrived! Just flicking through the pages and I think it should give me enough to become self-sufficient. One of the sections is about how to add a new method, and it shows how you do it TDD-style, which is cool. It uses the example of making a shouty string, like converting it to uppercase and then adding an explanation mark at the end.

*** Everything in the browser

I'm starting to make sense of it now; pretty much everything is done via the browser. It feels a little fiddly to search through, but I suppose I've just not found an easy way of doing that yet.

Just to get into the habit, I scrolled through the list of objects to see if there were any that would talk to the network. Poking around ~Network-Url~ and also ~NetworkTests-Url~ gave me a good idea of how to download the contents of a URL and then print them out into the transcript. I tried it out on my own website.

#+begin_src smalltalk
testUrl := 'https://leemeichin.com' asUrl.
Transcript open; show: testUrl retrieveContents contents.
#+end_src

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/printurl.png
[[../../assets/img/raytracing-challenge-smalltalk/printurl.png]]

*** No-code before no-code was cool

It feels more useful to provide screenshots of all of this, and I've wondered if this is an example of a 'no-code' sort of programming environment. It's not visual in the sense of connecting nodes together to form a graph though, which is what a lot of visual languages and no-code products do.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/morph.png
[[../../assets/img/raytracing-challenge-smalltalk/morph.png]]

One of the powerful features is that literally everything is configurable. If I middle click on one of the windows it becomes surrounded by a bunch of little tools that allow me to play with the UI, debug it, customise it, and more. Squeak calls it Morph, and it seems like an evolution of MVC. I think Pharo has a very similar thing.

What separates Smalltalk from these other no-code tools, I think, is that it accepts that you will actually have to write code at some point if you want to build anything useful. You know, like how Haskell accepts that non-pure code needs to exist if you want programs that actually /do something/.

Smalltalk and its environments seem to solve that problem by giving you interactive tools to create and organise code. It's quite interesting really and it makes me wonder how something similar would look if you rendered the contents of a running Ruby VM in the same way.

*** It's all older than I am

I guess I can only marvel at the various kinds of systems that were built so many decades ago that all show how cool it can be to work with a dynamic programming language. Lisp is old enough to be my dad and the way of working with Lisp was to basically modify the program as it was running (this is pretty much how Emacs works via emacs-lisp) via a REPL. It feels like you might do similar with Smalltalk, too.

Neither of these are like C, C++, Rust, or other compiled languages that require an executable to be compiled and then shipped, or deployed. Ruby offers a middle ground, I suppose, which is also what makes it a pleasure to work with.

Anyway, I haven't made too much progress today but I think I understand more. I'll come back tomorrow and see if I can figure out how to render an empty canvas or just something I can draw things onto.

** Day 3

Opened up Sqeak so I could get cracking today. Must have saved the image in a weird state last night since it was behaving strangely. Managed to close the project and make a fresh one and that was fine.

*** Data structures

The ray tracer challenge book starts off by defining some data structures. I think I'll get on with that first, so I can feel like I've achieved something.

I suppose it'll be useful to keep all of the objects I create under one category, so I created one called RayTracerChallenge. It doesn't do anything by itself though, so some new classes are needed.

The first one is a tuple, which contains 3D co-ordinates and an extra value to state whether this is a point in space, or a direction (or vector). All I had to do here was update the code example in the browser and save it, and then the class was created.

(One thing that feels odd is listing instance variables as a space separated string. Not even a list data structure.)

#+begin_src smalltalk
  Object subclass: #Tuple
         instanceVariableNames: 'x y z pointOrVector'
         classVariableNames: ''
         poolDictionaries: ''
         category: 'RayTracerChallenge'
#+end_src

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/tuple.png
[[../../assets/img/raytracing-challenge-smalltalk/tuple.png]]

I'll make two subclasses from that, called Point and Vector. The only difference is that one will initialise ~pointOrVector~ to ~0~ and the other will initialise it to ~1~. I'll leave screenshots out this time.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/conflict.png
[[../../assets/img/raytracing-challenge-smalltalk/conflict.png]]

Oh...I guess these objects aren't namespaced or anything. I'll just add a prefix to each object instead, like ~RTC~ for RayTracerChallenge. Reminds me of how it was in Objective-C.

In fact, why not do this TDD-style. I'll make some tests first.

#+begin_src smalltalk
  TestCase subclass: #RTCTupleTest
           instanceVariableNames: ''
           classVariableNames: ''
           poolDictionaries: ''
           category: 'RayTracerChallenge-Tests'.
#+end_src

#+begin_src smalltalk
  RTCTupleTest»testAsPoint
      "A tuple where w is set to 1 is a point"
      tuple := RTCTuple asPoint.
      self assert: (tuple class asString) equals: 'RTCPoint'.
      self assert: (tuple w) equals: 1.
#+end_src

#+begin_src smalltalk
  RTCTupleTest»testAsVector
      "A tuple where w is set to 0 is a vector"
      tuple := RTCTuple asVector.
      self assert: (tuple class asString) equals: 'RTCVector'.
      self assert: (tuple w) equals: 1.
#+end_src

#+begin_aside
~»~ isn't actual Smalltalk syntax, because adding new methods is done through the browser inside Squeak. It's just used to show an object and the name of a method. A bit like in Ruby where ~RTCTupleTest#testAsVector~ would describe an instance method called ~testAsVector~ on a class called ~RTCTupleTest~.
#+end_aside

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/testing.png
[[../../assets/img/raytracing-challenge-smalltalk/testing.png]]

There's a lot of clicking around and not very much typing so far, so it definitely feels slower as I get to grips with this. It actually occurs to me that the Acme editor from Plan9 is quite similar, except it does it all through text rather than UI widgets.

These tests aren't passing, of course, because I don't have my Point and Vector subclasses. The joy of TDD here is that I can automatically add them via the UI. Which I just did. After that, they just needed to be initialised with sensible defaults and some accessors.

#+begin_src smalltalk
  RTCTuple»initialize
      x := 0.
      y := 0.
      z := 0.
      w := 0.
#+end_src

#+begin_src smalltalk
  RTCVector»initialize
      w := 0.
#+end_src

#+begin_src smalltalk
  RTCPoint»initialize
      w := 1.
#+end_src

The ~w~ field is readonly to avoid mixing up Points and Vectors by changing the state of the object.

*** Mathemologics

Turns out there's still a fair bit to do with these objects: I've got to make them comparable and it has to be possible to do maths with them, e.g. adding two tuples together, or subtracting them, or multiplying them as you would with a matrix.

According to my two Smalltalk books, it seems like Smalltalk has an abstract class called ~Magnitude~ which is used for comparison. All I need to do is define an implementation for ~=~ (equals), ~<~ (less than) and ~hash~ and then I'll get a lot of convenience methods from it. Before I do that, it would be more helpful to define some arithmetic operations though, so that I can use subtraction to compare two objects for example.

**** Subtraction

As usual, tests first and then implementation second. I'm using the test examples from the ray tracer book and my vague knowledge of vector maths from the last time I messed around with games and stuff.

#+begin_src smalltalk
  RTCTupleTest»testSubtractTwoPoints
    "Subtracting two points creates a vector describing the distance between two points."
    | pointA pointB |

    pointA := RTCTuple asPoint x: 3 y: 2 z: 1.
    pointB := RTCTuple asPoint x: 5 y: 6 z: 7.

    self assert: (RTCTuple asVector x: -2 y: -4 z: -6) equals: pointA - pointB.
#+end_src

Subtracting one point from another doesn't mean I'll get another point, I'll actually get the distance between those two points instead, which is a vector. But when I subtract a vector from a point instead, then I /will/ get another point.

#+begin_src smalltalk
  RTCTupleTest»testSubtractVectorFromPoint
      "Subtracting a vector from a point results in another point."
      | vector point |

      vector := RTCTuple asVector x: 5 y: 6 z: 7.
      point := RTCTuple asPoint x: 3 y: 2 z: 1.

      self assert: (RTCTuple asPoint x: -2 y: -4 z: -6) equals: point - vector.
#+end_src

The test debugger is kinda cool, actually, although the output could be more helpful. I haven't got to the testing chapters in the books yet, so I expect that I've just missed out some things that would show me more useful info.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/testfail.png
[[../../assets/img/raytracing-challenge-smalltalk/testfail.png]]

Back to the maths, the implementation of the subtraction feature is this (and it's in that screenshot too):

#+begin_src smalltalk
  RTCTuple»- aTuple
      "Subtract aTuple from this tuple"
      ^RTCTuple
          x: x - aTuple x
          y: y - aTuple y
          z: z - aTuple z
          w: w - aTuple w.
#+end_src

All it does is make a new tuple by taking the values of one tuple and removing them from the other. The use of ~w~ to tell the difference between a point or vector makes it very easy to convert them, without having loads of logic to check if a Point should become a Vector, or vice-versa. I also notice I haven't really used the special subclasses I made because of this.

There are some other tests I need to add but they follow the same pattern: subtracting two vectors gives me another vector. And there is the edge case where it doesn't make sense to subtract a point from a vector.

**** Addition

I'm just going to breeze through the rest of these because otherwise I'll be rewriting the whole damn book.

#+begin_aside
Note to self: figure out git and how to publish these changes on a repo.
#+end_aside

Addition is like subtraction, so there's not much to do there. It has a similar edge-case in terms of adding two points together, but I'm not going to bother handling errors.

#+begin_src smalltalk
  RTCTuple»+ aTuple
      "Add aTuple on to this tuple, resulting in either another point or a vector"
      ^RTCTuple
          x: x + aTuple x
          y: y + aTuple y
          z: z + aTuple z
          w: w + aTuple w.
#+end_src

**** Negation

Getting the opposite a vector (or negating it) is a case of subtracting it from a 'zero' value. I've already done subtraction, so this is child's play.

#+begin_src smalltalk
  RTCTuple»negate
    "Create a tuple with the opposite values, e.g. by swapping the signs. The w value is not affected."
    ^(RTCTuple zero) - self
#+end_src

**** Distance

In rendering, a vector can represent a distance. It's basically the length of a straight line from the starting point of the vector to the ending point.

In fact it's not so different to calculating the hypotenuse of a triangle, except this time there are three dimensions rather than two.

#+begin_src smalltalk
  RTCVector»length
      "Calculate the distance represented by a vector."
      ^(x squared + y squared + z squared) sqrt
#+end_src

I added that one to my Vector subclass, since it doesn't make sense to calculate the length of a point.

*** Wrapping up for the day

Between taking notes on my progress and going through the challenge, it's taken maybe half a day to get to this point. I think that's enough for one day, I've still got the rest of the week ahead of me after all. And I'm starting to feel more comfortable in the environment which is nice.

Looks like the next chapter is actually about rendering. I've still got to handle a couple more operations (like the dot product and cross product) but I'll finish that up later.

Until tomorrow, dear diary!

** Day 3.5

I really wanted to finish off this first chapter, so I did! Using the example in the ray tracer challenge book, I made a little ticker in the workspace to demonstrate a projectile falling to the ground.

*** Console Cannon

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/cannons.png
[[../../assets/img/raytracing-challenge-smalltalk/cannons.png]]

I'll just leave it here, it's a nice little toy example. The ~Projectile~ and ~Environment~ objects are just containers for some vectors and points. The ~Ticker~ calculates a new position based on the projectile's velocity and some values corresponding to wind and gravity.

#+begin_src smalltalk
      Transcript clear.

      p := RTCProjectile
              withPosition: (RTCTuple asPoint x: 0 y: 1 z: 0)
              andVelocity: (RTCTuple asVector x: 1 y: 1 z: 0) normalize.

      e := RTCEnvironment
              withWind: (RTCTuple asVector x: 0 y: -0.1 z: 0)
               andGravity:  (RTCTuple asVector x: -0.01 y: 0 z: 0).

      t := RTCTicker new.

      i := 1.
      [ p position y > 0 ] whileTrue: [
          Transcript showln: 'Tick #', i asString.

          p := t tickwithEnv: e andProj: p.

          Transcript showln: 'X: ' , (p position x) asString;
                     showln: 'Y: ', (p position y) asString.

          i  := i + 1.
      ]
#+end_src

Now to play some real games.

** Day 4

A lovely winter morning indeed, and here I am back at my desk to do more of this challenge.

Flicking through the second chapter, it seems to start off with a bit of colour theory but there isn't anything scary there. In fact, in terms of implementation I'm set up for re-using all of the stuff I did with tuples, vectors and points yesterday.

*** The smalltalk standard library

There's nothing special to show off here, I just made another subclass of my ~RTCTuple~ and then created fresh accessor functions to refer to ~x~, ~y~ and ~z~ as ~red~, ~green~ and ~blue~ respectively.

Smalltalk already has a ~Color~ object, the same as it has a ~Point~ object, and I was tempted to use those instead of my home-grown copies. I decided against it because the Point only represented two dimensions and I need three, and as convenient as the Color one might be I would be making things needlessly difficult by having to convert it back and forth.

*** I'm not good with colours

I had to add a function to calculate the Hadamard product of two colours. The hadamard product is similar to calculating the dot product of a vector, but rather than getting a scalar value back that represents the sum of ~x~, ~y~ and ~z~, you get a new colour where the two reds were multiplied, the two greens, and the two blues.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/hadamard.png
[[../../assets/img/raytracing-challenge-smalltalk/hadamard.png]]

Since I'm not good with colours, my attempts to demonstrate how it works aren't so good. I just plugged a few different numbers in until I got something that wasn't black.

*** Data driven design

I'm reminded of what little I know about data driven design, where one is encouraged to work with primitive data structures over high level abstractions around them. A list of structs might be more effective to work with than a collection of classes, for example.

Knowing how much I'm typing things like ~RTCVector new x: 1 y: 2 z: 3~, I'm considering adding some convenience methods to the array object.

#+begin_src smalltalk
  #(1 2 3) asVector.
  #(0.1 0.2 0.3) asColor. "I bet this already exists"
  #(4 5 6) asPoint.
  #(1 2 3 0) asTuple.
#+end_src

I'll come back to that one later, since I'm bikeshedding. The real problem is that I made a generic tuple and rather than indexing into it, I gave the values names that only make sense for vectors and points.

For now I'll make it work and then I'll go and tidy it up.

*** Hello world but for rendering

Now for the fun part and slightly more difficult part! Yay!

By doing the demo with colours I figured out how to draw things into the workspace. Squeak calls these ~Morphs~, presumably because the framework is called Morphic. I can do basic things like change their colour, add text into them, put other UI thingies into them and so on. Looking through the documentation though I'm not convinced that this is low level enough since I need to be able to draw individual pixels. I need something like an OpenGL canvas.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/blackimage.png
[[../../assets/img/raytracing-challenge-smalltalk/blackimage.png]]

After a bit of playing around I've got something that renders into an image. Like another hello world I suppose :).

#+begin_src smalltalk
  RTCRenderer»initialize
      form := Form extent: 800@600 depth: 32.
      form fillBlack.
      canvas := FormCanvas on: form.
      image := ImageMorph new.
      image image: form.
      image position: 30@30.
      image openInWorld.
#+end_src

#+begin_aside
  I didn't realise that dimensions are first-class in Smalltalk with the ~x@y~ syntax. They resolve to an instance of ~Point~, but unfortunately that isn't three-dimensional.
#+end_aside

I'm under no illusion that rendering code is inherently procedural, so I expect that I'll be wrangling a few bulky methods sooner or later. I've already moved the image rendering out of the initialize method though. And I changed ~openInWorld~ to ~openInHand~, which basically puts the image under my cursor in drag-and-drop mode so I can place it where I like.

#+begin_src smalltalk
  RTCRenderer»display
      "Renders the form/canvas to an image morph in the world."
      | morph |
      
      morph := ImageMorph new.
      morph image: form;
            position: 30@30;
            openInHand.
#+end_src

I did have some trouble getting to this point. Some of the examples I found essentially drew the buffer straight onto the workspace. There's some situation where that is required (as it is when you run games in fullscreen mode and they take over the entire display instead of going through the windowing system), but for me it meant that the 'image' would be destroyed by dragging some other UI over it. It's like accessing or writing over memory you don't own. The extra step to make a 'morph' basically turned this into a self-contained canvas that I can play with more safely.

*** Drawing pixels

The book's moved on to drawing individual pixels now. This is normally the point where I'd give up on testing and just start eyeballing shit, but I'm interested to see if I can get these tests to pass.

**** The test case

The Ray Tracer Challenge book provides test cases in the form of BDD specs, using Gherkin-style syntax. This is maybe one of the one situations where BDD-style specs work /well/, because the author of the book wrote them to describe, well, the behaviour of the things you need to implement. Usually when someone gets the idea of setting up, say, Cucumber, they skip that step where someone in product actually writes up the specs to help disambiguate requirements, and so it falls onto the programmer to write both the Cukes and also the test cases themselves. No one outside of engineering actually bothers to read these, because they're stored alongside the code.

And I digress... I've converted the spec in the book to a little test case here. It obviously fails.

#+begin_src smalltalk
  RTCRendererTest»testWritePixelAt
      | renderer color point |

      renderer := RTCRenderer new.
      color := RTCColor new r: 1 g: 0 b: 0.
      point := RTCPoint new x: 2 y: 3 z: 0.

      renderer drawPixelAtPoint: point withColor: color.

      self assert: color equals: (renderer pixelAt: point).
#+end_src

I've made some up-front decisions on the interface here. Seems sensible enough I think.

The smalltalk (Squeak) environment is actually really nice for this. Because you're only seeing one method at a time, and because the structure of the method requires you to write document and declare your local variables up front, you can structure your tests in such a way that you only need to read the first few lines to get a feel for what will happen next.

These tests are all /super small/ as a result.

**** The implementation

Based on the test I created, I have a good idea of what I need to do. When I made the ~RTCRenderer~ class I stored a ~FormCanvas~ context as an instance variable, which is the thing I will do all of my drawing on. So, I just need to poke around the browser to see what I can do with one of these canvases.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/canvasform.png
[[../../assets/img/raytracing-challenge-smalltalk/canvasform.png]]

I wasn't sure what exactly to look for, by name at least, but I need a way to draw a pixel of a given colour onto a canvas and I need a way to find the colour of a given pixel. So, one write operation and one read operation.

#+begin_aside
By pixel I mean a specific point on the canvas at ~x~ and ~y~ co-ordinates, where the origin (~0~) is at the top left.
#+end_aside

For drawing, it looks like I can call ~point:color:~ on the canvas object but I'll need to convert my 3D point to a 2D one (note to self: can I drop the RTC prefixes and refer to my version of Point as ~3DPoint~?), and I'll need to convert my home-made Color object too as the built-in one does lots of things my version can't. No biggie.

#+begin_src smalltalk
  RTCRenderer»drawPixelAtPoint: point withColor: color
      "Draws a pixel at the x and y coordinates of point with the given color."

      canvas point: (point x)@(point y) color: color asColor.
#+end_src

I have a feeling that most of these methods I add will be simple wrappers over what Smalltalk already offers.

Anyway, that's one part of the test done, but I don't have an easy way to check that what I did is correct besides rendering it, which is awkward. How do I find the value of a pixel on my canvas?

/Ten minutes later.../

The canvas doesn't have a way to do this that I can tell, but the implementation of ~Canvas»point:color:~ manipulates an internal ~Form~ object. Objects all the way down. That form object defines ~colorAt:put:~ and, just as I thought, it means there is a ~colorAt~ method too.

#+begin_src smalltalk
  RTCRenderer»pixelAt: point
      "Returns the colour of the pixel at point"
      | color |

      color := canvas form colorAt: point. "...duck typing, yay"
      ^ RTCColor new r: (color red) g: (color green) b: (color blue).
#+end_src

Test has just gone from red to green. Woohoo!

*** Writing to disk

The next step of the book talks about writing the image to disk. It talks about writing the contents of the canvas to PPM (Portable Pixmap) format.

Honestly? I don't wanna do that when I already have the tools to create a PNG or a JPEG from this canvas. The PPM format is quite literally a space separated list of RGB values for pixels, with some metadata to define the resolution of the image and how many colours are supported.

Imma just make a PNG instead since this is a distraction from the main challenge.

#+begin_src smalltalk
  RTCRenderer»exportPNG: filename
    "Export the canvas to PNG for your viewing pleasure."
     canvas form writePNGfileNamed: filename
#+end_src

*** Console Cannons v2

I should have enough here to take the console cannon example from yesterday and render an image instead of writing values to the transcript.

Hopefully this script should be enough.

#+begin_src smalltalk
  p := RTCProjectile 
          withPosition: (RTCTuple asPoint x: 0 y: 1 z: 0) 
          andVelocity: ((RTCTuple asVector x: 1 y: 1.8 z: 0) normalize) * 11.25.
	
  e := RTCEnvironment 
          withWind: (RTCTuple asVector x: 0 y: -0.1 z: 0)
           andGravity:  (RTCTuple asVector x: -0.01 y: 0 z: 0).
	
  t := RTCTicker new.

  r := RTCRenderer new.

  i := 1.

  [ p position y > 0 ] whileTrue: [
          p := t tickwithEnv: e andProj: p.
          r drawPixelAtPoint: (p position) withColor: (RTCColor new r: 0 g: 1 b: 0).
          i  := i + 1.
  ].

  r writePNG: 'cannonsv2.png'.
#+end_src

And here's the result:

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/cannonsv2.png
[[../../assets/img/raytracing-challenge-smalltalk/cannonsv2.png]]


Wow, not bad! It's close enough to the example in the book, the only difference is that I hard-coded the size of the canvas to 800x600 so the velocity of the projectile sends it out of the picture.

Luckily I'm not doing this in C or anything so I don't have to care about bounds checking, eh? ;)

Oh yeah, it's also upside down. I suppose I could just rotate the image in an editor but where's the fun in that? All I need to do is subtract the Y co-ordinate from the height of the canvas, so ~600 - y~ really.

#+begin_src smalltalk
  [ p position y > 0 ] whileTrue: [
          p := t tickwithEnv: e andProj: p.
          r drawPixelAtPoint: (p position x)@(600 - p position y)
            withColor: (RTCColor new r: 0 g: 1 b: 0).
          i  := i + 1.
  ].
#+end_src

There's probably a fancy vector-based way to do that but right now I don't know it. The results are in, though!

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/cannonsv2fix.png
[[../../assets/img/raytracing-challenge-smalltalk/cannonsv2fix.png]]

Perfect!

*** Wrapping up for the day

And that actually marks the end of the chapter, so I'm gonna call it a day here. One big takeaway from today's adventure was that there isn't that much to be gained from turning to the internet for help. In fact, I think I might have googled something /once/, and I've spent less time referring to my two Smalltalk books.

I mean, they're still useful for reference but now I'm more familiar with Squeak, the immense discoverability of the environment is starting to take over. Not only that, but I'm already comfortable browsing for methods and then seeing what the docs and the implementations say. Smalltalk code, so far, is /remarkably/ easy to follow. This actually feels more like my experience with Ruby now, where I would generally browse through Ruby's docs and the lists of methods to see if there was anything that would help me out (Enumerable is a classic example of this, easily one of the best bits of Ruby).

That said, matrices and matric transformations are on the menu tomorrow, so we're back to the mathemology again.

I think I said this last time but chances are I'll gloss over much of that, so I can get the foundational work out of the way and come back to the sexy graphical stuff.

Until tomorrow!

** Day 5

Technically it's day 3 since I started over the weekend and spent 2 days just setting up. Anyway, I was supposed to take time off work and I'm treating this challenge like a day job.

I've got my mug of hot coffee (some brew from Kenya this time, I get a random packet every 2 weeks; always love a surprise) and I think I'll spend the morning playing more of Chrono Trigger.

I'll come back to the matrix stuff later on - I did have a look around and Smalltalk again has its own implementation of a Matrix. I'll go with the book and roll my own for now and then summarise the bits that I found interesting.


[fn:1] http://raytracerchallenge.com/
[fn:2] https://wiki.c2.com/?PurpleBook
[fn:3] https://pharo.org/, https://squeak.org, and https://www.gnu.org/software/smalltalk/ respectively
[fn:4] https://www.libsdl.org/
[fn:5] https://uk.bookshop.org/a/6865/9783952334102
