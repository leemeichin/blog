#+TITLE: Ray Tracer Challenge: Smalltalk
#+DATE: <2021-12-12 Sun>
#+CATEGORY: programming

Dear diary,

It looks like I have some time off coming up, and it feels like a good chance to try something different. I've had The Ray Tracer Challenge[fn:1] for almost a year now and haven't even touched it yet! And it would be really cool to make use of that copy of the Smalltalk-80 Purple Book I've had lying around for almost as long.

I wonder how far we can get in the space of a week. Don't worry, diary, I'll let you know how it goes.

#+TOC: headlines 3

** Day 1

*** Setting up my environment

So it looks like I can choose Pharo, Squeak, or GNU Smalltalk[fn:3]. The introduction to the GNU version says it closely follows Smalltalk-80, so that should be useful I think! It also says it's headless, so it can be used with files, and has some bindings to graphics libraries like SDL[fn:4], but doesn't have a graphical environment like the other two.

Documentation seems fairly minimal but apparently Smalltalk is self-descriptive, so many I'm not supposed to be searching the web for these things.

Perhaps I'll get Squeak ready instead.

*** This Smalltalk book is quite weird

Hm, a lot of the examples in the Purple Book don't seem to directly correspond to the syntax I would type into the environment. The implementation description reads like a spec, in layout and formatting, so I'm not sure if that's something I actually write in code somewhere.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/book-syntax.jpg
[[../../assets/img/raytracing-challenge-smalltalk/book-syntax.jpg]]

I can only assume this is all in reference to the original Smalltalk environment. The thing is I can make sense of what it's describing, I'm just not sure how to /write/ it or where I would actually put this code.

That said, I really do like this way of documenting code and it's clear some thought has been put into how to organise it too. It reminds me a bit of regions in C# or pragmas in Objective-C, except that those use special comments to group things in large objects.

*** How the fuck do you actually do something?

Alright, people say that switching from object-oriented code like Ruby or Java to something pure functional like Haskell is difficult, because it requires a different way of thinking.

I challenge that assertion!

It would still take me only a few minutes to do a trivial hello world in Haskell, C, Ruby, Java, C++, Javascript, or any other similar language. I put *code* into a *file* and then I point the interpreter or compiler to that file and then I either get ~"Hello, World!"~ straight away or a nice executable that will then print it out.

The example in Smalltalk is to open a workspace and use an object called ~Transcript~, but it doesn't seem much different to doing ~console.log~ inside my browser's console.

#+begin_src smalltalk
  "Semicolon is called cascading, which is like method chaining"
  Transcript open; show: 'Hello world!'.
#+end_src

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/helloworld.png
[[../../assets/img/raytracing-challenge-smalltalk/helloworld.png]]

I guess that's enough to play around with things, but I want to do this ray tracer challenge and for that I need to learn how to make classes. Then I can use the workspace or a special renderer class to make it appear on the screen.

So, it looks like I probably have to do something with the browser, to set up a little hierarchy for my project. Looking through the stuff that's there, there's all sorts of stuff I can look at. And the code that appears when I click on a selector looks super similar to how things are printed in the Purple Book.

*** Thinking in images

I ordered a copy of Squeak By Example[fn:5] to help out, since I feel like I have to unlearn how I normally do programming. I'm so used to building everything as a hierarchy of files and directories, or placing everything into just a handful of files to begin with.

Turns out you have an /image/ and everything you do is saved inside it, and you basically live inside that image. Those workspaces are essentially REPLs, then, but you can also open as many of those as you want and when you save and reload the image, they will all be there still. Pretty cool!

Actually, it makes me wonder how you deploy stuff for other people to use, but that's a question for another time.

Anyway, I think I've done enough today. I'm sure that once I understand the fundamentals I can start thinking about the challenge I want to complete.

** Day 2

Squeak by Example arrived! Just flicking through the pages and I think it should give me enough to become self-sufficient. One of the sections is about how to add a new method, and it shows how you do it TDD-style, which is cool. It uses the example of making a shouty string, like converting it to uppercase and then adding an explanation mark at the end.

*** Everything in the browser

I'm starting to make sense of it now; pretty much everything is done via the browser. It feels a little fiddly to search through, but I suppose I've just not found an easy way of doing that yet.

Just to get into the habit, I scrolled through the list of objects to see if there were any that would talk to the network. Poking around ~Network-Url~ and also ~NetworkTests-Url~ gave me a good idea of how to download the contents of a URL and then print them out into the transcript. I tried it out on my own website.

#+begin_src smalltalk
testUrl := 'https://leemeichin.com' asUrl.
Transcript open; show: testUrl retrieveContents contents.
#+end_src

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/printurl.png
[[../../assets/img/raytracing-challenge-smalltalk/printurl.png]]

*** No-code before no-code was cool

It feels more useful to provide screenshots of all of this, and I've wondered if this is an example of a 'no-code' sort of programming environment. It's not visual in the sense of connecting nodes together to form a graph though, which is what a lot of visual languages and no-code products do.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/morph.png
[[../../assets/img/raytracing-challenge-smalltalk/morph.png]]

One of the powerful features is that literally everything is configurable. If I middle click on one of the windows it becomes surrounded by a bunch of little tools that allow me to play with the UI, debug it, customise it, and more. Squeak calls it Morph, and it seems like an evolution of MVC. I think Pharo has a very similar thing.

What separates Smalltalk from these other no-code tools, I think, is that it accepts that you will actually have to write code at some point if you want to build anything useful. You know, like how Haskell accepts that non-pure code needs to exist if you want programs that actually /do something/.

Smalltalk and its environments seem to solve that problem by giving you interactive tools to create and organise code. It's quite interesting really and it makes me wonder how something similar would look if you rendered the contents of a running Ruby VM in the same way.

*** It's all older than I am

I guess I can only marvel at the various kinds of systems that were built so many decades ago that all show how cool it can be to work with a dynamic programming language. Lisp is old enough to be my dad and the way of working with Lisp was to basically modify the program as it was running (this is pretty much how Emacs works via emacs-lisp) via a REPL. It feels like you might do similar with Smalltalk, too.

Neither of these are like C, C++, Rust, or other compiled languages that require an executable to be compiled and then shipped, or deployed. Ruby offers a middle ground, I suppose, which is also what makes it a pleasure to work with.

Anyway, I haven't made too much progress today but I think I understand more. I'll come back tomorrow and see if I can figure out how to render an empty canvas or just something I can draw things onto.

** Day 3

Opened up Sqeak so I could get cracking today. Must have saved the image in a weird state last night since it was behaving strangely. Managed to close the project and make a fresh one and that was fine.

*** Data structures

The ray tracer challenge book starts off by defining some data structures. I think I'll get on with that first, so I can feel like I've achieved something.

I suppose it'll be useful to keep all of the objects I create under one category, so I created one called RayTracerChallenge. It doesn't do anything by itself though, so some new classes are needed.

The first one is a tuple, which contains 3D co-ordinates and an extra value to state whether this is a point in space, or a direction (or vector). All I had to do here was update the code example in the browser and save it, and then the class was created.

(One thing that feels odd is listing instance variables as a space separated string. Not even a list data structure.)

#+begin_src smalltalk
Object subclass: #Tuple
        instanceVariableNames: 'x y z pointOrVector'
        classVariableNames: ''
        poolDictionaries: ''
        category: 'RayTracerChallenge'
#+end_src

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/tuple.png
[[../../assets/img/raytracing-challenge-smalltalk/tuple.png]]

I'll make two subclasses from that, called Point and Vector. The only difference is that one will initialise ~pointOrVector~ to ~0~ and the other will initialise it to ~1~. I'll leave screenshots out this time.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/conflict.png
[[../../assets/img/raytracing-challenge-smalltalk/conflict.png]]

Oh...I guess these objects aren't namespaced or anything. I'll just add a prefix to each object instead, like ~RTC~ for RayTracerChallenge. Reminds me of how it was in Objective-C.

In fact, why not do this TDD-style. I'll make some tests first.

#+begin_src smalltalk
  TestCase subclass: #RTCTupleTest
           instanceVariableNames: ''
           classVariableNames: ''
           poolDictionaries: ''
           category: 'RayTracerChallenge-Tests'.
#+end_src

#+begin_src smalltalk
  RTCTupleTest»testAsPoint
      "A tuple where w is set to 1 is a point"
      tuple := RTCTuple asPoint.
      self assert: (tuple class asString) equals: 'RTCPoint'.
      self assert: (tuple w) equals: 1.
#+end_src

#+begin_src smalltalk
  RTCTupleTest»testAsVector
      "A tuple where w is set to 0 is a vector"
      tuple := RTCTuple asVector.
      self assert: (tuple class asString) equals: 'RTCVector'.
      self assert: (tuple w) equals: 1.
#+end_src

#+begin_aside
~»~ isn't actual Smalltalk syntax, because adding new methods is done through the browser inside Squeak. It's just used to show an object and the name of a method. A bit like in Ruby where ~RTCTupleTest#testAsVector~ would describe an instance method called ~testAsVector~ on a class called ~RTCTupleTest~.
#+end_aside

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/testing.png
[[../../assets/img/raytracing-challenge-smalltalk/testing.png]]

There's a lot of clicking around and not very much typing so far, so it definitely feels slower as I get to grips with this. It actually occurs to me that the Acme editor from Plan9 is quite similar, except it does it all through text rather than UI widgets.

These tests aren't passing, of course, because I don't have my Point and Vector subclasses. The joy of TDD here is that I can automatically add them via the UI. Which I just did. After that, they just needed to be initialised with sensible defaults and some accessors.

#+begin_src smalltalk
  RTCTuple»initialize
      x := 0.
      y := 0.
      z := 0.
      w := 0.
#+end_src

#+begin_src smalltalk
  RTCVector»initialize
      w := 0.
#+end_src

#+begin_src smalltalk
  RTCPoint»initialize
      w := 1.
#+end_src

The ~w~ field is readonly to avoid mixing up Points and Vectors by changing the state of the object.

*** Mathemologics

Turns out there's still a fair bit to do with these objects: I've got to make them comparable and it has to be possible to do maths with them, e.g. adding two tuples together, or subtracting them, or multiplying them as you would with a matrix.

According to my two Smalltalk books, it seems like Smalltalk has an abstract class called ~Magnitude~ which is used for comparison. All I need to do is define an implementation for ~=~ (equals), ~<~ (less than) and ~hash~ and then I'll get a lot of convenience methods from it. Before I do that, it would be more helpful to define some arithmetic operations though, so that I can use subtraction to compare two objects for example.

**** Subtraction

As usual, tests first and then implementation second. I'm using the test examples from the ray tracer book and my vague knowledge of vector maths from the last time I messed around with games and stuff.

#+begin_src smalltalk
  RTCTupleTest»testSubtractTwoPoints
    "Subtracting two points creates a vector describing the distance between two points."
    | pointA pointB |

    pointA := RTCTuple asPoint x: 3 y: 2 z: 1.
    pointB := RTCTuple asPoint x: 5 y: 6 z: 7.

    self assert: (RTCTuple asVector x: -2 y: -4 z: -6) equals: pointA - pointB.
#+end_src

Subtracting one point from another doesn't mean I'll get another point, I'll actually get the distance between those two points instead, which is a vector. But when I subtract a vector from a point instead, then I /will/ get another point.

#+begin_src smalltalk
  RTCTupleTest»testSubtractVectorFromPoint
      "Subtracting a vector from a point results in another point."
      | vector point |

      vector := RTCTuple asVector x: 5 y: 6 z: 7.
      point := RTCTuple asPoint x: 3 y: 2 z: 1.

      self assert: (RTCTuple asPoint x: -2 y: -4 z: -6) equals: point - vector.
#+end_src

The test debugger is kinda cool, actually, although the output could be more helpful. I haven't got to the testing chapters in the books yet, so I expect that I've just missed out some things that would show me more useful info.

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/testfail.png
[[../../assets/img/raytracing-challenge-smalltalk/testfail.png]]

Back to the maths, the implementation of the subtraction feature is this (and it's in that screenshot too):

#+begin_src smalltalk
  RTCTuple»- aTuple
      "Subtract aTuple from this tuple"
      ^RTCTuple
          x: x - aTuple x
          y: y - aTuple y
          z: z - aTuple z
          w: w - aTuple w.
#+end_src

All it does is make a new tuple by taking the values of one tuple and removing them from the other. The use of ~w~ to tell the difference between a point or vector makes it very easy to convert them, without having loads of logic to check if a Point should become a Vector, or vice-versa. I also notice I haven't really used the special subclasses I made because of this.

There are some other tests I need to add but they follow the same pattern: subtracting two vectors gives me another vector. And there is the edge case where it doesn't make sense to subtract a point from a vector.

**** Addition

I'm just going to breeze through the rest of these because otherwise I'll be rewriting the whole damn book.

#+begin_aside
Note to self: figure out git and how to publish these changes on a repo.
#+end_aside

Addition is like subtraction, so there's not much to do there. It has a similar edge-case in terms of adding two points together, but I'm not going to bother handling errors.

#+begin_src smalltalk
  RTCTuple»+ aTuple
      "Add aTuple on to this tuple, resulting in either another point or a vector"
      ^RTCTuple
          x: x + aTuple x
          y: y + aTuple y
          z: z + aTuple z
          w: w + aTuple w.
#+end_src

**** Negation

Getting the opposite a vector (or negating it) is a case of subtracting it from a 'zero' value. I've already done subtraction, so this is child's play.

#+begin_src smalltalk
  RTCTuple»negate
    "Create a tuple with the opposite values, e.g. by swapping the signs. The w value is not affected."
    ^(RTCTuple zero) - self
#+end_src

**** Distance

In rendering, a vector can represent a distance. It's basically the length of a straight line from the starting point of the vector to the ending point.

In fact it's not so different to calculating the hypotenuse of a triangle, except this time there are three dimensions rather than two.

#+begin_src smalltalk
  RTCVector»length
      "Calculate the distance represented by a vector."
      ^(x squared + y squared + z squared) sqrt
#+end_src

I added that one to my Vector subclass, since it doesn't make sense to calculate the length of a point.

*** Wrapping up for the day

Between taking notes on my progress and going through the challenge, it's taken maybe half a day to get to this point. I think that's enough for one day, I've still got the rest of the week ahead of me after all. And I'm starting to feel more comfortable in the environment which is nice.

Looks like the next chapter is actually about rendering. I've still got to handle a couple more operations (like the dot product and cross product) but I'll finish that up later.

Until tomorrow, dear diary!

** Day 3: Evening

I really wanted to finish off this first chapter, so I did! Using the example in the ray tracer challenge book, I made a little ticker in the workspace to demonstrate a projectile falling to the ground.

*** Console Cannon

#+ATTR_HTML: :src /img/raytracing-challenge-smalltalk/cannons.png
[[../../assets/img/raytracing-challenge-smalltalk/cannons.png]]

I'll just leave it here, it's a nice little toy example. The ~Projectile~ and ~Environment~ objects are just containers for some vectors and points. The ~Ticker~ calculates a new position based on the projectile's velocity and some values corresponding to wind and gravity.

#+begin_src smalltalk
      Transcript clear.

      p := RTCProjectile
              withPosition: (RTCTuple asPoint x: 0 y: 1 z: 0)
              andVelocity: (RTCTuple asVector x: 1 y: 1 z: 0) normalize.

      e := RTCEnvironment
              withWind: (RTCTuple asVector x: 0 y: -0.1 z: 0)
               andGravity:  (RTCTuple asVector x: -0.01 y: 0 z: 0).

      t := RTCTicker new.

      i := 1.
      [ p position y > 0 ] whileTrue: [
              Transcript showln: 'Tick #', i asString.

              p := t tickwithEnv: e andProj: p.

              Transcript showln: 'X: ' , (p position x) asString;
                         showln: 'Y: ', (p position y) asString.

              i  := i + 1.
      ]
#+end_src

Now to play some real games.

[fn:1] http://raytracerchallenge.com/
[fn:2] https://wiki.c2.com/?PurpleBook
[fn:3] https://pharo.org/, https://squeak.org, and https://www.gnu.org/software/smalltalk/ respectively
[fn:4] https://www.libsdl.org/
[fn:5] https://uk.bookshop.org/a/6865/9783952334102
